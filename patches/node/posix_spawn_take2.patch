From 4e0f426a5d77d4de93e518e77b3596c765b97515 Mon Sep 17 00:00:00 2001
From: Jameson Nash <vtjnash@gmail.com>
Date: Mon, 26 Jul 2021 13:07:09 -0400
Subject: [PATCH 1/8] Re-land "macos: use posix_spawn instead of fork"

This reverts commit 217fdf4265589889d00c7c0622fde2710971a020.
---
 src/unix/process.c | 540 ++++++++++++++++++++++++++++++++++++++++++---
 1 file changed, 513 insertions(+), 27 deletions(-)

diff --git a/deps/uv/src/unix/process.c b/deps/uv/src/unix/process.c
index 2920b94296..204741ea21 100644
--- a/deps/uv/src/unix/process.c
+++ b/deps/uv/src/unix/process.c
@@ -27,6 +27,7 @@
 #include <assert.h>
 #include <errno.h>
 #include <signal.h>
+#include <string.h>
 
 #include <sys/types.h>
 #include <sys/wait.h>
@@ -35,8 +36,20 @@
 #include <poll.h>
 
 #if defined(__APPLE__) && !TARGET_OS_IPHONE
+# include <spawn.h>
+# include <paths.h>
+# include <sys/kauth.h>
+# include <sys/types.h>
+# include <sys/sysctl.h>
+# include <dlfcn.h>
 # include <crt_externs.h>
 # define environ (*_NSGetEnviron())
+
+/* macOS 10.14 back does not define this constant */
+# ifndef POSIX_SPAWN_SETSID
+#  define POSIX_SPAWN_SETSID 1024
+# endif
+
 #else
 extern char **environ;
 #endif
@@ -327,9 +340,8 @@ static void uv__process_child_init(const uv_process_options_t* options,
   if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid))
     uv__write_errno(error_fd);
 
-  if (options->env != NULL) {
+  if (options->env != NULL)
     environ = options->env;
-  }
 
   /* Reset signal mask just before exec. */
   sigemptyset(&signewset);
@@ -348,6 +360,497 @@ static void uv__process_child_init(const uv_process_options_t* options,
 #endif
 
 
+#if defined(__APPLE__)
+typedef struct uv__posix_spawn_fncs_tag {
+  struct {
+    int (*set_uid_np)(const posix_spawnattr_t *, uid_t);
+    int (*set_gid_np)(const posix_spawnattr_t *, gid_t);
+    int (*set_groups_np)(const posix_spawnattr_t*, int, gid_t*, uid_t);
+  } spawnattr;
+
+  struct {
+    int (*addchdir_np)(const posix_spawn_file_actions_t *, const char *);
+  } file_actions;
+} uv__posix_spawn_fncs_t;
+
+
+static uv_once_t posix_spawn_init_once = UV_ONCE_INIT;
+static uv__posix_spawn_fncs_t posix_spawn_fncs;
+static int posix_spawn_can_use_setsid;
+
+
+void uv__spawn_init_posix_spawn_fncs(void) {
+  /* Try to locate all non-portable functions at runtime */
+  posix_spawn_fncs.spawnattr.set_uid_np =
+    dlsym(RTLD_DEFAULT, "posix_spawnattr_set_uid_np");
+  posix_spawn_fncs.spawnattr.set_gid_np =
+    dlsym(RTLD_DEFAULT, "posix_spawnattr_set_gid_np");
+  posix_spawn_fncs.spawnattr.set_groups_np =
+    dlsym(RTLD_DEFAULT, "posix_spawnattr_set_groups_np");
+  posix_spawn_fncs.file_actions.addchdir_np =
+    dlsym(RTLD_DEFAULT, "posix_spawn_file_actions_addchdir_np");
+}
+
+
+void uv__spawn_init_can_use_setsid(void) {
+  static const int MACOS_CATALINA_VERSION_MAJOR = 19;
+  char version_str[256];
+  char* version_major_str;
+  size_t version_str_size = 256;
+  int r;
+  int version_major;
+
+  /* By default, assume failure */
+  posix_spawn_can_use_setsid = 0;
+
+  /* Get a version string */
+  r = sysctlbyname("kern.osrelease", version_str, &version_str_size, NULL, 0);
+  if (r != 0)
+    return;
+
+  /* Try to get the major version number. If not found
+   * fall back to the fork/exec flow */
+  version_major_str = strtok(version_str, ".");
+  if (version_major_str == NULL)
+    return;
+
+  /* Parse the version major as a number. If it is greater than
+   * the major version for macOS Catalina (aka macOS 10.15), then
+   * the POSIX_SPAWN_SETSID flag is available */
+  version_major = atoi(version_major_str);
+  if (version_major >= MACOS_CATALINA_VERSION_MAJOR)
+    posix_spawn_can_use_setsid = 1;
+}
+
+
+void uv__spawn_init_posix_spawn(void) {
+  /* Init handles to all potentially non-defined functions */
+  uv__spawn_init_posix_spawn_fncs();
+
+  /* Init feature detection for POSIX_SPAWN_SETSID flag */
+  uv__spawn_init_can_use_setsid();
+}
+
+
+int uv__spawn_set_posix_spawn_attrs(posix_spawnattr_t* attrs,
+                                    const uv__posix_spawn_fncs_t* posix_spawn_fncs,
+                                    const uv_process_options_t* options) {
+  int err;
+  unsigned int flags;
+  sigset_t signal_set;
+
+  err = posix_spawnattr_init(attrs);
+  if (err != 0) {
+    /* If initialization fails, no need to de-init, just return */
+    return err;
+  }
+
+  if (options->flags & UV_PROCESS_SETUID) {
+    if (posix_spawn_fncs->spawnattr.set_uid_np == NULL) {
+      err = ENOSYS;
+      goto error;
+    }
+
+    err = posix_spawn_fncs->spawnattr.set_uid_np(attrs, options->uid);
+    if (err != 0)
+      goto error;
+  }
+
+  if (options->flags & UV_PROCESS_SETGID) {
+    if (posix_spawn_fncs->spawnattr.set_gid_np == NULL) {
+      err = ENOSYS;
+      goto error;
+    }
+
+    err = posix_spawn_fncs->spawnattr.set_gid_np(attrs, options->gid);
+    if (err != 0)
+      goto error;
+  }
+
+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
+    /* Using ngroups = 0 implied the group_array is empty, and so
+     * its contents are never traversed. Still the
+     * posix_spawn_set_groups_np function seems to require that the
+     * group_array pointer be non-null */
+    const int ngroups = 0;
+    gid_t group_array = KAUTH_GID_NONE;
+
+    if (posix_spawn_fncs->spawnattr.set_groups_np == NULL) {
+      err = ENOSYS;
+      goto error;
+    }
+
+    /* See the comment on the call to setgroups in uv__process_child_init above
+     * for why this is not a fatal error */
+    SAVE_ERRNO(posix_spawn_fncs->spawnattr.set_groups_np(
+      attrs,
+      ngroups,
+      &group_array,
+      KAUTH_UID_NONE));
+  }
+
+  /* Set flags for spawn behavior
+    * 1) POSIX_SPAWN_CLOEXEC_DEFAULT: (Apple Extension) All descriptors in
+    * the parent will be treated as if they had been created with O_CLOEXEC.
+    * The only fds that will be passed on to the child are those manipulated
+    * by the file actions
+    * 2) POSIX_SPAWN_SETSIGDEF: Signals mentioned in spawn-sigdefault in
+    * the spawn attributes will be reset to behave as their default
+    * 3) POSIX_SPAWN_SETSIGMASK: Signal mask will be set to the value of
+    * spawn-sigmask in attributes
+    * 4) POSIX_SPAWN_SETSID: Make the process a new session leader if a
+    * detached session was requested. */
+  flags = POSIX_SPAWN_CLOEXEC_DEFAULT |
+          POSIX_SPAWN_SETSIGDEF |
+          POSIX_SPAWN_SETSIGMASK;
+  if (options->flags & UV_PROCESS_DETACHED) {
+    /* If running on a version of macOS where this flag is not supported,
+     * revert back to the fork/exec flow. Otherwise posix_spawn will
+     * silently ignore the flag. */
+    if (!posix_spawn_can_use_setsid) {
+      err = ENOSYS;
+      goto error;
+    }
+
+    flags |= POSIX_SPAWN_SETSID;
+  }
+  err = posix_spawnattr_setflags(attrs, flags);
+  if (err != 0)
+    goto error;
+
+  /*  Reset all signal the child to their default behavior */
+  sigfillset(&signal_set);
+  err = posix_spawnattr_setsigdefault(attrs, &signal_set);
+  if (err != 0)
+    goto error;
+
+  /*  Reset the signal mask for all signals */
+  sigemptyset(&signal_set);
+  err = posix_spawnattr_setsigmask(attrs, &signal_set);
+  if (err != 0)
+    goto error;
+
+  return err;
+
+error:
+  (void) posix_spawnattr_destroy(attrs);
+  return err;
+}
+
+
+int uv__spawn_set_posix_spawn_file_actions(posix_spawn_file_actions_t* actions,
+                                           const uv__posix_spawn_fncs_t* posix_spawn_fncs,
+                                           const uv_process_options_t* options,
+                                           int stdio_count,
+                                           int (*pipes)[2]) {
+  int fd;
+  int err;
+
+  err = posix_spawn_file_actions_init(actions);
+  if (err != 0) {
+    /* If initialization fails, no need to de-init, just return */
+    return err;
+  }
+
+  /* Set the current working directory if requested */
+  if (options->cwd != NULL) {
+    if (posix_spawn_fncs->file_actions.addchdir_np == NULL) {
+      err = ENOSYS;
+      goto error;
+    }
+
+    err = posix_spawn_fncs->file_actions.addchdir_np(actions, options->cwd);
+    if (err != 0)
+      goto error;
+  }
+
+  /* First, duplicate any required fd into orbit, out of the range of
+   * the descriptors that should be mapped in. */
+  for (fd = 0; fd < stdio_count; fd++) {
+    if (pipes[fd][1] < 0)
+      continue;
+
+    err = posix_spawn_file_actions_adddup2(
+      actions,
+      pipes[fd][1],
+      stdio_count + fd);
+    if (err != 0)
+      goto error;
+  }
+
+  /*  Second, move the descriptors into their respective places */
+  for (fd = 0; fd < stdio_count; fd++) {
+    if (pipes[fd][1] < 0)
+      continue;
+
+    err = posix_spawn_file_actions_adddup2(actions, stdio_count + fd, fd);
+    if (err != 0)
+      goto error;
+  }
+
+  /*  Finally, close all the superfluous descriptors */
+  for (fd = 0; fd < stdio_count; fd++) {
+    if (pipes[fd][1] < 0)
+      continue;
+
+    err = posix_spawn_file_actions_addclose(actions, stdio_count + fd);
+    if (err != 0)
+      goto error;
+  }
+
+  /*  Finally process the standard streams as per documentation */
+  for (fd = 0; fd < 3; fd++) {
+    int oflags;
+    const int mode = 0;
+
+    oflags = fd == 0 ? O_RDONLY : O_RDWR;
+
+    if (pipes[fd][1] != -1) {
+      /* If not ignored, make sure the fd is marked as non-blocking */
+      uv__nonblock_fcntl(pipes[fd][1], 0);
+    } else {
+      /* If ignored, redirect to (or from) /dev/null, */
+      err = posix_spawn_file_actions_addopen(
+        actions,
+        fd,
+        "/dev/null",
+        oflags,
+        mode);
+      if (err != 0)
+        goto error;
+    }
+  }
+
+  return 0;
+
+error:
+  (void) posix_spawn_file_actions_destroy(actions);
+  return err;
+}
+
+char* uv__spawn_find_path_in_env(char** env) {
+  char** env_iterator;
+  const char path_var[] = "PATH=";
+
+  /* Look for an environment variable called PATH in the
+   * provided env array, and return its value if found */
+  for (env_iterator = env; *env_iterator != NULL; env_iterator++) {
+    if (strncmp(*env_iterator, path_var, sizeof(path_var) - 1) == 0) {
+      /* Found "PATH=" at the beginning of the string */
+      return *env_iterator + sizeof(path_var) - 1;
+    }
+  }
+
+  return NULL;
+}
+
+
+int uv__spawn_resolve_and_spawn(const uv_process_options_t* options,
+                                posix_spawnattr_t* attrs,
+                                posix_spawn_file_actions_t* actions,
+                                pid_t* pid) {
+  const char *p;
+  const char *z;
+  const char *path;
+  size_t l;
+  size_t k;
+  int err;
+
+  path = NULL;
+  err = -1;
+
+  /* Short circuit for erroneous case */
+  if (options->file == NULL)
+    return ENOENT;
+
+  /* The environment for the child process is that of the parent unless overriden
+   * by options->env */
+  char** env = environ;
+  if (options->env != NULL)
+    env = options->env;
+
+  /* If options->file contains a slash, posix_spawn/posix_spawnp behave
+   * the same, and don't involve PATH resolution at all. Otherwise, if
+   * options->file does not include a slash, but no custom environment is
+   * to be used, the environment used for path resolution as well for the
+   * child process is that of the parent process, so posix_spawnp is the
+   * way to go. */
+  if (strchr(options->file, '/') != NULL || options->env == NULL)
+    return posix_spawnp(pid, options->file, actions, attrs, options->args, env);
+
+  /* Look for the definition of PATH in the provided env */
+  path = uv__spawn_find_path_in_env(options->env);
+
+  /* The following resolution logic (execvpe emulation) is taken from
+   * https://github.com/JuliaLang/libuv/commit/9af3af617138d6a6de7d72819ed362996ff255d9
+   * and adapted to work around our own situations */
+
+  /* If no path was provided in options->env, use the default value
+   * to look for the executable */
+  if (path == NULL)
+    path = _PATH_DEFPATH;
+
+  k = strnlen(options->file, NAME_MAX + 1);
+  if (k > NAME_MAX)
+    return ENAMETOOLONG;
+
+  l = strnlen(path, PATH_MAX - 1) + 1;
+
+  for (p = path;; p = z) {
+    /* Compose the new process file from the entry in the PATH
+     * environment variable and the actual file name */
+    char b[PATH_MAX + NAME_MAX];
+    z = strchr(p, ':');
+    if (!z)
+      z = p + strlen(p);
+    if ((size_t)(z - p) >= l) {
+      if (!*z++)
+        break;
+
+      continue;
+    }
+    memcpy(b, p, z - p);
+    b[z - p] = '/';
+    memcpy(b + (z - p) + (z > p), options->file, k + 1);
+
+    /* Try to spawn the new process file. If it fails with ENOENT, the
+     * new process file is not in this PATH entry, continue with the next
+     * PATH entry. */
+    err = posix_spawn(pid, b, actions, attrs, options->args, env);
+    if (err != ENOENT)
+      return err;
+
+    if (!*z++)
+      break;
+  }
+
+  return err;
+}
+
+
+int uv__spawn_and_init_child_posix_spawn(const uv_process_options_t* options,
+                                         int stdio_count,
+                                         int (*pipes)[2],
+                                         pid_t* pid,
+                                         const uv__posix_spawn_fncs_t* posix_spawn_fncs) {
+  int err;
+  posix_spawnattr_t attrs;
+  posix_spawn_file_actions_t actions;
+
+  err = uv__spawn_set_posix_spawn_attrs(&attrs, posix_spawn_fncs, options);
+  if (err != 0)
+    goto error;
+
+  err = uv__spawn_set_posix_spawn_file_actions(
+    &actions,
+    posix_spawn_fncs,
+    options,
+    stdio_count,
+    pipes);
+  if (err != 0) {
+    (void) posix_spawnattr_destroy(&attrs);
+    goto error;
+  }
+
+  /* Try to spawn options->file resolving in the provided environment
+   * if any */
+  err = uv__spawn_resolve_and_spawn(options, &attrs, &actions, pid);
+
+  /* Destroy the actions/attributes */
+  (void) posix_spawn_file_actions_destroy(&actions);
+  (void) posix_spawnattr_destroy(&attrs);
+
+error:
+  /* In an error situation, the attributes and file actions are
+   * already destroyed, only the happy path requires cleanup */
+  return UV__ERR(err);
+}
+#endif
+
+int uv__spawn_and_init_child_fork(const uv_process_options_t* options,
+                                  int stdio_count,
+                                  int (*pipes)[2],
+                                  int error_fd,
+                                  pid_t* pid) {
+  sigset_t signewset;
+  sigset_t sigoldset;
+
+  /* Start the child with most signals blocked, to avoid any issues before we
+   * can reset them, but allow program failures to exit (and not hang). */
+  sigfillset(&signewset);
+  sigdelset(&signewset, SIGKILL);
+  sigdelset(&signewset, SIGSTOP);
+  sigdelset(&signewset, SIGTRAP);
+  sigdelset(&signewset, SIGSEGV);
+  sigdelset(&signewset, SIGBUS);
+  sigdelset(&signewset, SIGILL);
+  sigdelset(&signewset, SIGSYS);
+  sigdelset(&signewset, SIGABRT);
+  if (pthread_sigmask(SIG_BLOCK, &signewset, &sigoldset) != 0)
+    abort();
+
+  *pid = fork();
+
+  if (*pid == -1) {
+    /* Failed to fork */
+    return UV__ERR(errno);
+  }
+
+  if (*pid == 0) {
+    /* Fork succeeded, in the child process */
+    uv__process_child_init(options, stdio_count, pipes, error_fd);
+    abort();
+  }
+
+  if (pthread_sigmask(SIG_SETMASK, &sigoldset, NULL) != 0)
+    abort();
+
+  /* Fork succeeded, in the parent process */
+  return 0;
+}
+
+int uv__spawn_and_init_child(const uv_process_options_t* options,
+                             int stdio_count,
+                             int (*pipes)[2],
+                             int error_fd,
+                             pid_t* pid) {
+  int err;
+
+#if defined(__APPLE__)
+  uv_once(&posix_spawn_init_once, uv__spawn_init_posix_spawn);
+
+  /* Special child process spawn case for macOS Big Sur (11.0) onwards
+   *
+   * Big Sur introduced a significant performance degradation on a call to
+   * fork/exec when the process has many pages mmaped in with MAP_JIT, like, say
+   * a javascript interpreter. Electron-based applications, for example,
+   * are impacted; though the magnitude of the impact depends on how much the
+   * app relies on subprocesses.
+   *
+   * On macOS, though, posix_spawn is implemented in a way that does not
+   * exhibit the problem. This block implements the forking and preparation
+   * logic with posix_spawn and its related primitives. It also takes advantage of
+   * the macOS extension POSIX_SPAWN_CLOEXEC_DEFAULT that makes impossible to
+   * leak descriptors to the child process. */
+  err = uv__spawn_and_init_child_posix_spawn(options,
+                                              stdio_count,
+                                              pipes,
+                                              pid,
+                                              &posix_spawn_fncs);
+
+  /* The posix_spawn flow will return UV_ENOSYS if any of the posix_spawn_x_np
+   * non-standard functions is both _needed_ and _undefined_. In those cases,
+   * default back to the fork/execve strategy. For all other errors, just fail. */
+  if (err != UV_ENOSYS)
+    return err;
+
+#endif
+
+  err = uv__spawn_and_init_child_fork(options, stdio_count, pipes, error_fd, pid);
+
+  return err;
+}
+
 int uv_spawn(uv_loop_t* loop,
              uv_process_t* process,
              const uv_process_options_t* options) {
@@ -355,8 +858,6 @@ int uv_spawn(uv_loop_t* loop,
   /* fork is marked __WATCHOS_PROHIBITED __TVOS_PROHIBITED. */
   return UV_ENOSYS;
 #else
-  sigset_t signewset;
-  sigset_t sigoldset;
   int signal_pipe[2] = { -1, -1 };
   int pipes_storage[8][2];
   int (*pipes)[2];
@@ -434,29 +935,14 @@ int uv_spawn(uv_loop_t* loop,
   /* Acquire write lock to prevent opening new fds in worker threads */
   uv_rwlock_wrlock(&loop->cloexec_lock);
 
-  /* Start the child with most signals blocked, to avoid any issues before we
-   * can reset them, but allow program failures to exit (and not hang). */
-  sigfillset(&signewset);
-  sigdelset(&signewset, SIGKILL);
-  sigdelset(&signewset, SIGSTOP);
-  sigdelset(&signewset, SIGTRAP);
-  sigdelset(&signewset, SIGSEGV);
-  sigdelset(&signewset, SIGBUS);
-  sigdelset(&signewset, SIGILL);
-  sigdelset(&signewset, SIGSYS);
-  sigdelset(&signewset, SIGABRT);
-  if (pthread_sigmask(SIG_BLOCK, &signewset, &sigoldset) != 0)
-    abort();
-
-  pid = fork();
-  if (pid == -1)
-    err = UV__ERR(errno);
-
-  if (pid == 0)
-    uv__process_child_init(options, stdio_count, pipes, signal_pipe[1]);
-
-  if (pthread_sigmask(SIG_SETMASK, &sigoldset, NULL) != 0)
-    abort();
+  /* Spawn the child */
+  err = uv__spawn_and_init_child(options, stdio_count, pipes, signal_pipe[1], &pid);
+  if (err != 0) {
+    uv_rwlock_wrunlock(&loop->cloexec_lock);
+    uv__close(signal_pipe[0]);
+    uv__close(signal_pipe[1]);
+    goto error;
+  }
 
   /* Release lock in parent process */
   uv_rwlock_wrunlock(&loop->cloexec_lock);

From c203584fdb27b2e79a026992cbe13642b23a4297 Mon Sep 17 00:00:00 2001
From: Jameson Nash <vtjnash@gmail.com>
Date: Mon, 26 Jul 2021 13:47:45 -0400
Subject: [PATCH 2/8] spawn: remove error fast-cleanup code that triggers a
 nodejs bug

Refs: https://github.com/libuv/libuv/pull/3107#issuecomment-782482608
---
 src/unix/process.c | 58 ++++++++++++++++++++++------------------------
 1 file changed, 28 insertions(+), 30 deletions(-)

diff --git a/deps/uv/src/unix/process.c b/deps/uv/src/unix/process.c
index 204741ea21..a901962172 100644
--- a/deps/uv/src/unix/process.c
+++ b/deps/uv/src/unix/process.c
@@ -936,47 +936,45 @@ int uv_spawn(uv_loop_t* loop,
   uv_rwlock_wrlock(&loop->cloexec_lock);
 
   /* Spawn the child */
-  err = uv__spawn_and_init_child(options, stdio_count, pipes, signal_pipe[1], &pid);
-  if (err != 0) {
-    uv_rwlock_wrunlock(&loop->cloexec_lock);
-    uv__close(signal_pipe[0]);
-    uv__close(signal_pipe[1]);
-    goto error;
-  }
+  exec_errorno = uv__spawn_and_init_child(options, stdio_count, pipes, signal_pipe[1], &pid);
 
   /* Release lock in parent process */
   uv_rwlock_wrunlock(&loop->cloexec_lock);
 
   uv__close(signal_pipe[1]);
 
-  if (pid == -1) {
-    uv__close(signal_pipe[0]);
-    goto error;
-  }
-
   process->status = 0;
-  exec_errorno = 0;
-  do
-    r = read(signal_pipe[0], &exec_errorno, sizeof(exec_errorno));
-  while (r == -1 && errno == EINTR);
-
-  if (r == 0)
-    ; /* okay, EOF */
-  else if (r == sizeof(exec_errorno)) {
-    do
-      err = waitpid(pid, &status, 0); /* okay, read errorno */
-    while (err == -1 && errno == EINTR);
-    assert(err == pid);
-  } else if (r == -1 && errno == EPIPE) {
+  if (exec_errorno == 0) {
     do
-      err = waitpid(pid, &status, 0); /* okay, got EPIPE */
-    while (err == -1 && errno == EINTR);
-    assert(err == pid);
-  } else
-    abort();
+      r = read(signal_pipe[0], &exec_errorno, sizeof(exec_errorno));
+    while (r == -1 && errno == EINTR);
+
+    if (r == 0)
+      ; /* okay, EOF */
+    else if (r == sizeof(exec_errorno)) {
+      do
+        err = waitpid(pid, &status, 0); /* okay, read errorno */
+      while (err == -1 && errno == EINTR);
+      assert(err == pid);
+    } else if (r == -1 && errno == EPIPE) {
+      do
+        err = waitpid(pid, &status, 0); /* okay, got EPIPE */
+      while (err == -1 && errno == EINTR);
+      assert(err == pid);
+    } else
+      abort();
+  }
 
   uv__close_nocheckstdio(signal_pipe[0]);
 
+#if 0
+  /* This runs into a nodejs issue (it expects initialized streams, even if the
+   * exec failed).
+   * See https://github.com/libuv/libuv/pull/3107#issuecomment-782482608 */
+  if (exec_errorno != 0)
+      goto error;
+#endif
+
   for (i = 0; i < options->stdio_count; i++) {
     err = uv__process_open_stream(options->stdio + i, pipes[i]);
     if (err == 0)

From 20a503c7078910355a53f03cd89e6c33eb65f7df Mon Sep 17 00:00:00 2001
From: Jameson Nash <vtjnash@gmail.com>
Date: Mon, 26 Jul 2021 13:58:06 -0400
Subject: [PATCH 3/8] darwin: protect posix_spawn from EINTR

This is not a documented valid error, but seems to have been observed.
---
 src/unix/process.c | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/deps/uv/src/unix/process.c b/deps/uv/src/unix/process.c
index a901962172..c562cda45a 100644
--- a/deps/uv/src/unix/process.c
+++ b/deps/uv/src/unix/process.c
@@ -675,8 +675,12 @@ int uv__spawn_resolve_and_spawn(const uv_process_options_t* options,
    * to be used, the environment used for path resolution as well for the
    * child process is that of the parent process, so posix_spawnp is the
    * way to go. */
-  if (strchr(options->file, '/') != NULL || options->env == NULL)
-    return posix_spawnp(pid, options->file, actions, attrs, options->args, env);
+  if (strchr(options->file, '/') != NULL || options->env == NULL) {
+    do
+      err = posix_spawnp(pid, options->file, actions, attrs, options->args, env);
+    while (err == EINTR);
+    return err;
+  }
 
   /* Look for the definition of PATH in the provided env */
   path = uv__spawn_find_path_in_env(options->env);
@@ -716,7 +720,10 @@ int uv__spawn_resolve_and_spawn(const uv_process_options_t* options,
     /* Try to spawn the new process file. If it fails with ENOENT, the
      * new process file is not in this PATH entry, continue with the next
      * PATH entry. */
-    err = posix_spawn(pid, b, actions, attrs, options->args, env);
+    do
+      err = posix_spawn(pid, b, actions, attrs, options->args, env);
+    while (err == EINTR);
+
     if (err != ENOENT)
       return err;
 

From 2100482f150d35ccfca0b9b861faac2b126dfa9d Mon Sep 17 00:00:00 2001
From: Jameson Nash <vtjnash@gmail.com>
Date: Mon, 26 Jul 2021 14:13:07 -0400
Subject: [PATCH 4/8] darwin,spawn: ignore setuid/setgid syscall

This kernel function is not permitted unless the process is setuid root,
so disable this syscall. Falling back to fork/exec should be okay for
the rare cases that the user decides they need to do setuid(getuid()) or
setuid(geteuid()) for the child.

Refs: https://github.com/libuv/libuv/pull/3107#issuecomment-782482608
---
 src/unix/process.c | 59 +++++-----------------------------------------
 1 file changed, 6 insertions(+), 53 deletions(-)

diff --git a/deps/uv/src/unix/process.c b/deps/uv/src/unix/process.c
index c562cda45a..8ddcab8869 100644
--- a/deps/uv/src/unix/process.c
+++ b/deps/uv/src/unix/process.c
@@ -362,12 +362,6 @@ static void uv__process_child_init(const uv_process_options_t* options,
 
 #if defined(__APPLE__)
 typedef struct uv__posix_spawn_fncs_tag {
-  struct {
-    int (*set_uid_np)(const posix_spawnattr_t *, uid_t);
-    int (*set_gid_np)(const posix_spawnattr_t *, gid_t);
-    int (*set_groups_np)(const posix_spawnattr_t*, int, gid_t*, uid_t);
-  } spawnattr;
-
   struct {
     int (*addchdir_np)(const posix_spawn_file_actions_t *, const char *);
   } file_actions;
@@ -381,12 +375,6 @@ static int posix_spawn_can_use_setsid;
 
 void uv__spawn_init_posix_spawn_fncs(void) {
   /* Try to locate all non-portable functions at runtime */
-  posix_spawn_fncs.spawnattr.set_uid_np =
-    dlsym(RTLD_DEFAULT, "posix_spawnattr_set_uid_np");
-  posix_spawn_fncs.spawnattr.set_gid_np =
-    dlsym(RTLD_DEFAULT, "posix_spawnattr_set_gid_np");
-  posix_spawn_fncs.spawnattr.set_groups_np =
-    dlsym(RTLD_DEFAULT, "posix_spawnattr_set_groups_np");
   posix_spawn_fncs.file_actions.addchdir_np =
     dlsym(RTLD_DEFAULT, "posix_spawn_file_actions_addchdir_np");
 }
@@ -445,48 +433,13 @@ int uv__spawn_set_posix_spawn_attrs(posix_spawnattr_t* attrs,
     return err;
   }
 
-  if (options->flags & UV_PROCESS_SETUID) {
-    if (posix_spawn_fncs->spawnattr.set_uid_np == NULL) {
-      err = ENOSYS;
-      goto error;
-    }
-
-    err = posix_spawn_fncs->spawnattr.set_uid_np(attrs, options->uid);
-    if (err != 0)
-      goto error;
-  }
-
-  if (options->flags & UV_PROCESS_SETGID) {
-    if (posix_spawn_fncs->spawnattr.set_gid_np == NULL) {
-      err = ENOSYS;
-      goto error;
-    }
-
-    err = posix_spawn_fncs->spawnattr.set_gid_np(attrs, options->gid);
-    if (err != 0)
-      goto error;
-  }
-
   if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
-    /* Using ngroups = 0 implied the group_array is empty, and so
-     * its contents are never traversed. Still the
-     * posix_spawn_set_groups_np function seems to require that the
-     * group_array pointer be non-null */
-    const int ngroups = 0;
-    gid_t group_array = KAUTH_GID_NONE;
-
-    if (posix_spawn_fncs->spawnattr.set_groups_np == NULL) {
-      err = ENOSYS;
-      goto error;
-    }
-
-    /* See the comment on the call to setgroups in uv__process_child_init above
-     * for why this is not a fatal error */
-    SAVE_ERRNO(posix_spawn_fncs->spawnattr.set_groups_np(
-      attrs,
-      ngroups,
-      &group_array,
-      KAUTH_UID_NONE));
+      /* kauth_cred_issuser currently requires exactly uid == 0 for these
+       * posixspawn_attrs (set_groups_np, setuid_np, setgid_np), which deviates
+       * from the normal specification of setuid (which also uses euid), and
+       * they are also undocumented syscalls, so we do not use them. */
+    err = ENOSYS;
+    goto error;
   }
 
   /* Set flags for spawn behavior

From c816be5a79a2525d85e2941b8d2f7393faf2939d Mon Sep 17 00:00:00 2001
From: Jameson Nash <vtjnash@gmail.com>
Date: Mon, 26 Jul 2021 14:43:16 -0400
Subject: [PATCH 5/8] darwin,spawn: improve posix_spawn path search

Ports the improvements in musl back to this function
---
 src/unix/process.c | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/deps/uv/src/unix/process.c b/deps/uv/src/unix/process.c
index 8ddcab8869..7eb504e0ba 100644
--- a/deps/uv/src/unix/process.c
+++ b/deps/uv/src/unix/process.c
@@ -608,6 +608,7 @@ int uv__spawn_resolve_and_spawn(const uv_process_options_t* options,
   size_t l;
   size_t k;
   int err;
+  int seen_eacces;
 
   path = NULL;
   err = -1;
@@ -638,9 +639,9 @@ int uv__spawn_resolve_and_spawn(const uv_process_options_t* options,
   /* Look for the definition of PATH in the provided env */
   path = uv__spawn_find_path_in_env(options->env);
 
-  /* The following resolution logic (execvpe emulation) is taken from
-   * https://github.com/JuliaLang/libuv/commit/9af3af617138d6a6de7d72819ed362996ff255d9
-   * and adapted to work around our own situations */
+  /* The following resolution logic (execvpe emulation) is copied from
+   * https://git.musl-libc.org/cgit/musl/tree/src/process/execvp.c
+   * and adapted to work for our specific usage */
 
   /* If no path was provided in options->env, use the default value
    * to look for the executable */
@@ -677,13 +678,23 @@ int uv__spawn_resolve_and_spawn(const uv_process_options_t* options,
       err = posix_spawn(pid, b, actions, attrs, options->args, env);
     while (err == EINTR);
 
-    if (err != ENOENT)
+    switch (err) {
+    case EACCES:
+      seen_eacces = 1;
+      break; /* continue search */
+    case ENOENT:
+    case ENOTDIR:
+      break; /* continue search */
+    default:
       return err;
+    }
 
     if (!*z++)
       break;
   }
 
+  if (seen_eacces)
+    return EACCESS;
   return err;
 }
 

From 90678e9c4dd0b9e90e5285eff5f33392684e8ab0 Mon Sep 17 00:00:00 2001
From: Jameson Nash <vtjnash@gmail.com>
Date: Tue, 27 Jul 2021 11:33:56 -0400
Subject: [PATCH 6/8] Update src/unix/process.c

---
 src/unix/process.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/deps/uv/src/unix/process.c b/deps/uv/src/unix/process.c
index 7eb504e0ba..7345bd3ce5 100644
--- a/deps/uv/src/unix/process.c
+++ b/deps/uv/src/unix/process.c
@@ -694,7 +694,7 @@ int uv__spawn_resolve_and_spawn(const uv_process_options_t* options,
   }
 
   if (seen_eacces)
-    return EACCESS;
+    return EACCES;
   return err;
 }
 

From e84c7f039bde595d5ddedbc07e61ca2a8aca36ab Mon Sep 17 00:00:00 2001
From: Jameson Nash <vtjnash@gmail.com>
Date: Tue, 27 Jul 2021 12:19:12 -0400
Subject: [PATCH 7/8] Update src/unix/process.c

---
 src/unix/process.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/deps/uv/src/unix/process.c b/deps/uv/src/unix/process.c
index 7345bd3ce5..3596f06dd7 100644
--- a/deps/uv/src/unix/process.c
+++ b/deps/uv/src/unix/process.c
@@ -612,6 +612,7 @@ int uv__spawn_resolve_and_spawn(const uv_process_options_t* options,
 
   path = NULL;
   err = -1;
+  seen_eacces = 0;
 
   /* Short circuit for erroneous case */
   if (options->file == NULL)

From de45dcfaef0cdfb4191cb37a510430453867d0bd Mon Sep 17 00:00:00 2001
From: Jameson Nash <vtjnash@gmail.com>
Date: Mon, 31 Jan 2022 16:18:26 -0500
Subject: [PATCH 8/8] fix some additional problems and formatting issues

We previously might fail to start a watcher, in rare failure cases, resulting in a zombie that we would fail to kill.
Also avoid creating the signal-pipe unless required (addresses a review comment from Apple)
---
 src/unix/process.c | 238 ++++++++++++++++++++++++---------------------
 1 file changed, 125 insertions(+), 113 deletions(-)

diff --git a/deps/uv/src/unix/process.c b/deps/uv/src/unix/process.c
index 3596f06dd7..1dc2084a3c 100644
--- a/deps/uv/src/unix/process.c
+++ b/deps/uv/src/unix/process.c
@@ -233,10 +233,11 @@ static void uv__write_errno(int error_fd) {
  * avoided. Since this isn't called on those targets, the function
  * doesn't even need to be defined for them.
  */
-static void uv__process_child_init(const uv_process_options_t* options,
-                                   int stdio_count,
-                                   int (*pipes)[2],
-                                   int error_fd) {
+static void uv__process_child_init(
+        const uv_process_options_t* options,
+        int stdio_count,
+        int (*pipes)[2],
+        int error_fd) {
   sigset_t signewset;
   int close_fd;
   int use_fd;
@@ -373,14 +374,14 @@ static uv__posix_spawn_fncs_t posix_spawn_fncs;
 static int posix_spawn_can_use_setsid;
 
 
-void uv__spawn_init_posix_spawn_fncs(void) {
+static void uv__spawn_init_posix_spawn_fncs(void) {
   /* Try to locate all non-portable functions at runtime */
   posix_spawn_fncs.file_actions.addchdir_np =
     dlsym(RTLD_DEFAULT, "posix_spawn_file_actions_addchdir_np");
 }
 
 
-void uv__spawn_init_can_use_setsid(void) {
+static void uv__spawn_init_can_use_setsid(void) {
   static const int MACOS_CATALINA_VERSION_MAJOR = 19;
   char version_str[256];
   char* version_major_str;
@@ -411,7 +412,7 @@ void uv__spawn_init_can_use_setsid(void) {
 }
 
 
-void uv__spawn_init_posix_spawn(void) {
+static void uv__spawn_init_posix_spawn(void) {
   /* Init handles to all potentially non-defined functions */
   uv__spawn_init_posix_spawn_fncs();
 
@@ -420,9 +421,10 @@ void uv__spawn_init_posix_spawn(void) {
 }
 
 
-int uv__spawn_set_posix_spawn_attrs(posix_spawnattr_t* attrs,
-                                    const uv__posix_spawn_fncs_t* posix_spawn_fncs,
-                                    const uv_process_options_t* options) {
+static int uv__spawn_set_posix_spawn_attrs(
+        posix_spawnattr_t* attrs,
+        const uv__posix_spawn_fncs_t* posix_spawn_fncs,
+        const uv_process_options_t* options) {
   int err;
   unsigned int flags;
   sigset_t signal_set;
@@ -491,11 +493,12 @@ int uv__spawn_set_posix_spawn_attrs(posix_spawnattr_t* attrs,
 }
 
 
-int uv__spawn_set_posix_spawn_file_actions(posix_spawn_file_actions_t* actions,
-                                           const uv__posix_spawn_fncs_t* posix_spawn_fncs,
-                                           const uv_process_options_t* options,
-                                           int stdio_count,
-                                           int (*pipes)[2]) {
+static int uv__spawn_set_posix_spawn_file_actions(
+        posix_spawn_file_actions_t* actions,
+        const uv__posix_spawn_fncs_t* posix_spawn_fncs,
+        const uv_process_options_t* options,
+        int stdio_count,
+        int (*pipes)[2]) {
   int fd;
   int err;
 
@@ -598,10 +601,11 @@ char* uv__spawn_find_path_in_env(char** env) {
 }
 
 
-int uv__spawn_resolve_and_spawn(const uv_process_options_t* options,
-                                posix_spawnattr_t* attrs,
-                                posix_spawn_file_actions_t* actions,
-                                pid_t* pid) {
+static int uv__spawn_resolve_and_spawn(
+        const uv_process_options_t* options,
+        posix_spawnattr_t* attrs,
+        posix_spawn_file_actions_t* actions,
+        pid_t* pid) {
   const char *p;
   const char *z;
   const char *path;
@@ -700,11 +704,12 @@ int uv__spawn_resolve_and_spawn(const uv_process_options_t* options,
 }
 
 
-int uv__spawn_and_init_child_posix_spawn(const uv_process_options_t* options,
-                                         int stdio_count,
-                                         int (*pipes)[2],
-                                         pid_t* pid,
-                                         const uv__posix_spawn_fncs_t* posix_spawn_fncs) {
+static int uv__spawn_and_init_child_posix_spawn(
+        const uv_process_options_t* options,
+        int stdio_count,
+        int (*pipes)[2],
+        pid_t* pid,
+        const uv__posix_spawn_fncs_t* posix_spawn_fncs) {
   int err;
   posix_spawnattr_t attrs;
   posix_spawn_file_actions_t actions;
@@ -739,11 +744,12 @@ int uv__spawn_and_init_child_posix_spawn(const uv_process_options_t* options,
 }
 #endif
 
-int uv__spawn_and_init_child_fork(const uv_process_options_t* options,
-                                  int stdio_count,
-                                  int (*pipes)[2],
-                                  int error_fd,
-                                  pid_t* pid) {
+static int uv__spawn_and_init_child_fork(
+        const uv_process_options_t* options,
+        int stdio_count,
+        int (*pipes)[2],
+        int error_fd,
+        pid_t* pid) {
   sigset_t signewset;
   sigset_t sigoldset;
 
@@ -781,12 +787,17 @@ int uv__spawn_and_init_child_fork(const uv_process_options_t* options,
   return 0;
 }
 
-int uv__spawn_and_init_child(const uv_process_options_t* options,
-                             int stdio_count,
-                             int (*pipes)[2],
-                             int error_fd,
-                             pid_t* pid) {
+static int uv__spawn_and_init_child(
+        uv_loop_t* loop,
+        const uv_process_options_t* options,
+        int stdio_count,
+        int (*pipes)[2],
+        pid_t* pid) {
+  int signal_pipe[2] = { -1, -1 };
+  int status;
   int err;
+  int exec_errorno;
+  ssize_t r;
 
 #if defined(__APPLE__)
   uv_once(&posix_spawn_init_once, uv__spawn_init_posix_spawn);
@@ -805,10 +816,10 @@ int uv__spawn_and_init_child(const uv_process_options_t* options,
    * the macOS extension POSIX_SPAWN_CLOEXEC_DEFAULT that makes impossible to
    * leak descriptors to the child process. */
   err = uv__spawn_and_init_child_posix_spawn(options,
-                                              stdio_count,
-                                              pipes,
-                                              pid,
-                                              &posix_spawn_fncs);
+                                             stdio_count,
+                                             pipes,
+                                             pid,
+                                             &posix_spawn_fncs);
 
   /* The posix_spawn flow will return UV_ENOSYS if any of the posix_spawn_x_np
    * non-standard functions is both _needed_ and _undefined_. In those cases,
@@ -818,7 +829,65 @@ int uv__spawn_and_init_child(const uv_process_options_t* options,
 
 #endif
 
-  err = uv__spawn_and_init_child_fork(options, stdio_count, pipes, error_fd, pid);
+  /* This pipe is used by the parent to wait until
+   * the child has called `execve()`. We need this
+   * to avoid the following race condition:
+   *
+   *    if ((pid = fork()) > 0) {
+   *      kill(pid, SIGTERM);
+   *    }
+   *    else if (pid == 0) {
+   *      execve("/bin/cat", argp, envp);
+   *    }
+   *
+   * The parent sends a signal immediately after forking.
+   * Since the child may not have called `execve()` yet,
+   * there is no telling what process receives the signal,
+   * our fork or /bin/cat.
+   *
+   * To avoid ambiguity, we create a pipe with both ends
+   * marked close-on-exec. Then, after the call to `fork()`,
+   * the parent polls the read end until it EOFs or errors with EPIPE.
+   */
+  err = uv__make_pipe(signal_pipe, 0);
+  if (err)
+    return err;
+
+  /* Acquire write lock to prevent opening new fds in worker threads */
+  uv_rwlock_wrlock(&loop->cloexec_lock);
+
+  err = uv__spawn_and_init_child_fork(options, stdio_count, pipes, signal_pipe[1], pid);
+
+  /* Release lock in parent process */
+  uv_rwlock_wrunlock(&loop->cloexec_lock);
+
+  uv__close(signal_pipe[1]);
+
+  if (err == 0) {
+    do
+      r = read(signal_pipe[0], &exec_errorno, sizeof(exec_errorno));
+    while (r == -1 && errno == EINTR);
+
+    if (r == 0)
+      ; /* okay, EOF */
+    else if (r == sizeof(exec_errorno)) {
+      do
+        err = waitpid(*pid, &status, 0); /* okay, read errorno */
+      while (err == -1 && errno == EINTR);
+      assert(err == *pid);
+      err = exec_errorno;
+    } else if (r == -1 && errno == EPIPE) {
+      /* Something unknown happened to our child before spawn */
+      do
+        err = waitpid(*pid, &status, 0); /* okay, got EPIPE */
+      while (err == -1 && errno == EINTR);
+      assert(err == *pid);
+      err = UV_EPIPE;
+    } else
+      abort();
+  }
+
+  uv__close_nocheckstdio(signal_pipe[0]);
 
   return err;
 }
@@ -830,16 +899,13 @@ int uv_spawn(uv_loop_t* loop,
   /* fork is marked __WATCHOS_PROHIBITED __TVOS_PROHIBITED. */
   return UV_ENOSYS;
 #else
-  int signal_pipe[2] = { -1, -1 };
   int pipes_storage[8][2];
   int (*pipes)[2];
   int stdio_count;
-  ssize_t r;
   pid_t pid;
   int err;
   int exec_errorno;
   int i;
-  int status;
 
   assert(options->file != NULL);
   assert(!(options->flags & ~(UV_PROCESS_DETACHED |
@@ -852,6 +918,7 @@ int uv_spawn(uv_loop_t* loop,
 
   uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS);
   QUEUE_INIT(&process->queue);
+  process->status = 0;
 
   stdio_count = options->stdio_count;
   if (stdio_count < 3)
@@ -876,68 +943,12 @@ int uv_spawn(uv_loop_t* loop,
       goto error;
   }
 
-  /* This pipe is used by the parent to wait until
-   * the child has called `execve()`. We need this
-   * to avoid the following race condition:
-   *
-   *    if ((pid = fork()) > 0) {
-   *      kill(pid, SIGTERM);
-   *    }
-   *    else if (pid == 0) {
-   *      execve("/bin/cat", argp, envp);
-   *    }
-   *
-   * The parent sends a signal immediately after forking.
-   * Since the child may not have called `execve()` yet,
-   * there is no telling what process receives the signal,
-   * our fork or /bin/cat.
-   *
-   * To avoid ambiguity, we create a pipe with both ends
-   * marked close-on-exec. Then, after the call to `fork()`,
-   * the parent polls the read end until it EOFs or errors with EPIPE.
-   */
-  err = uv__make_pipe(signal_pipe, 0);
-  if (err)
-    goto error;
-
 #if !(defined(__APPLE__) || defined(__DragonFly__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__))
   uv_signal_start(&loop->child_watcher, uv__chld, SIGCHLD);
 #endif
 
-  /* Acquire write lock to prevent opening new fds in worker threads */
-  uv_rwlock_wrlock(&loop->cloexec_lock);
-
   /* Spawn the child */
-  exec_errorno = uv__spawn_and_init_child(options, stdio_count, pipes, signal_pipe[1], &pid);
-
-  /* Release lock in parent process */
-  uv_rwlock_wrunlock(&loop->cloexec_lock);
-
-  uv__close(signal_pipe[1]);
-
-  process->status = 0;
-  if (exec_errorno == 0) {
-    do
-      r = read(signal_pipe[0], &exec_errorno, sizeof(exec_errorno));
-    while (r == -1 && errno == EINTR);
-
-    if (r == 0)
-      ; /* okay, EOF */
-    else if (r == sizeof(exec_errorno)) {
-      do
-        err = waitpid(pid, &status, 0); /* okay, read errorno */
-      while (err == -1 && errno == EINTR);
-      assert(err == pid);
-    } else if (r == -1 && errno == EPIPE) {
-      do
-        err = waitpid(pid, &status, 0); /* okay, got EPIPE */
-      while (err == -1 && errno == EINTR);
-      assert(err == pid);
-    } else
-      abort();
-  }
-
-  uv__close_nocheckstdio(signal_pipe[0]);
+  exec_errorno = uv__spawn_and_init_child(loop, options, stdio_count, pipes, &pid);
 
 #if 0
   /* This runs into a nodejs issue (it expects initialized streams, even if the
@@ -947,18 +958,9 @@ int uv_spawn(uv_loop_t* loop,
       goto error;
 #endif
 
-  for (i = 0; i < options->stdio_count; i++) {
-    err = uv__process_open_stream(options->stdio + i, pipes[i]);
-    if (err == 0)
-      continue;
-
-    while (i--)
-      uv__process_close_stream(options->stdio + i);
-
-    goto error;
-  }
-
-  /* Only activate this handle if exec() happened successfully */
+  /* Activate this handle if exec() happened successfully, even if we later
+   * fail to open a stdio handle. This ensures we can eventually reap the child
+   * with waitpid. */
   if (exec_errorno == 0) {
 #if defined(__APPLE__) || defined(__DragonFly__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__)
     struct kevent event;
@@ -971,12 +973,22 @@ int uv_spawn(uv_loop_t* loop,
     }
 #endif
 
+    process->pid = pid;
+    process->exit_cb = options->exit_cb;
     QUEUE_INSERT_TAIL(&loop->process_handles, &process->queue);
     uv__handle_start(process);
   }
 
-  process->pid = pid;
-  process->exit_cb = options->exit_cb;
+  for (i = 0; i < options->stdio_count; i++) {
+    err = uv__process_open_stream(options->stdio + i, pipes[i]);
+    if (err == 0)
+      continue;
+
+    while (i--)
+      uv__process_close_stream(options->stdio + i);
+
+    goto error;
+  }
 
   if (pipes != pipes_storage)
     uv__free(pipes);
