From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Pat DeSantis <pdesantis3@gmail.com>
Date: Wed, 6 Jan 2021 21:49:11 -0500
Subject: darwin,libuv: use posix_spawn
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Spawning child processes in an Electron application with a hardened runtime has become slow in macOS Big Sur.

This patch is a squashed version of https://github.com/libuv/libuv/pull/3064, with the addition of API availability annotations to fix a build warning (since Electron compiles with the `-Wunguarded-availability-new` flag). This patch should be removed when libuv PR 3064 is merged.

Fixes: https://github.com/libuv/libuv/issues/3050
Fixes: https://github.com/electron/electron/issues/26143
PR-URL: https://github.com/libuv/libuv/pull/3064

Authored-by: Juan Pablo Canepa <jpcanepa@gmail.com>
Co-authored-by: Marcello Bast√©a-Forte <marcello@descript.com>
Electron patch prepared by: Pat DeSantis <pdesantis3@gmail.com>

diff --git a/deps/uv/src/unix/process.c b/deps/uv/src/unix/process.c
index b021aaeba87d0b466341f40a016ef69e8beb7543..4a3f490a39044acb4938176d8492881d7e39d011 100644
--- a/deps/uv/src/unix/process.c
+++ b/deps/uv/src/unix/process.c
@@ -34,8 +34,12 @@
 #include <poll.h>
 
 #if defined(__APPLE__) && !TARGET_OS_IPHONE
+# include <spawn.h>
+# include <sys/kauth.h>
+# include <dlfcn.h>
 # include <crt_externs.h>
 # define environ (*_NSGetEnviron())
+# include "darwin-stub.h"
 #else
 extern char **environ;
 #endif
@@ -404,6 +408,303 @@ static void uv__process_child_init(const uv_process_options_t* options,
 }
 #endif
 
+#if defined(__APPLE__)
+typedef struct uv__posix_spawn_fncs_tag {
+  struct {
+    int (*set_uid_np)(const posix_spawnattr_t *, uid_t);
+    int (*set_gid_np)(const posix_spawnattr_t *, gid_t);
+    int (*set_groups_np)(const posix_spawnattr_t*, int, gid_t*, uid_t);
+  } spawnattr;
+
+  struct {
+    int (*addchdir_np)(const posix_spawn_file_actions_t *, const char *);
+  } file_actions;
+} uv__posix_spawn_fncs_t;
+
+static uv_once_t posix_spawn_init_fncs_once = UV_ONCE_INIT;
+static uv__posix_spawn_fncs_t posix_spawn_fncs;
+
+void uv__spawn_init_posix_spawn_fncs() {
+  /* Try to locate all non-portable functions at runtime */
+  posix_spawn_fncs.spawnattr.set_uid_np = dlsym(RTLD_DEFAULT, "posix_spawnattr_set_uid_np");
+  posix_spawn_fncs.spawnattr.set_gid_np = dlsym(RTLD_DEFAULT, "posix_spawnattr_set_gid_np");
+  posix_spawn_fncs.spawnattr.set_groups_np = dlsym(RTLD_DEFAULT, "posix_spawnattr_set_groups_np");
+  posix_spawn_fncs.file_actions.addchdir_np = dlsym(RTLD_DEFAULT, "posix_spawn_file_actions_addchdir_np");
+}
+
+int uv__spawn_set_posix_spawn_attrs(posix_spawnattr_t* attrs,
+                                    const uv__posix_spawn_fncs_t* posix_spawn_fncs,
+                                    const uv_process_options_t* options)
+{
+  int err;
+  unsigned int flags;
+  sigset_t signal_set;
+
+  err = posix_spawnattr_init(attrs);
+  if (err != 0) {
+    /* If initialization fails, no need to de-init, just return */
+    return err;
+  }
+
+  if (options->flags & UV_PROCESS_SETUID) {
+    if (posix_spawn_fncs->spawnattr.set_uid_np == NULL) {
+      err = UV_ENOSYS;
+      goto error;
+    }
+
+    err = posix_spawn_fncs->spawnattr.set_uid_np(attrs, options->uid);
+    if (err != 0)
+      goto error;
+  }
+
+  if (options->flags & UV_PROCESS_SETGID) {
+    if (posix_spawn_fncs->spawnattr.set_gid_np == NULL) {
+      err = UV_ENOSYS;
+      goto error;
+    }
+
+    err = posix_spawn_fncs->spawnattr.set_gid_np(attrs, options->gid);
+    if (err != 0) 
+      goto error;
+  }
+
+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {
+    /* Using ngroups = 0 implied the group_array is empty, and so 
+     * its contents are never traversed. Still the 
+     * posix_spawn_set_groups_np function seems to require that the 
+     * group_array pointer be non-null */
+    const int ngroups = 0;
+    gid_t group_array = KAUTH_GID_NONE;
+
+    if (posix_spawn_fncs->spawnattr.set_groups_np == NULL) {
+      err = UV_ENOSYS;
+      goto error;
+    }
+    
+    /* See the comment on the call to setgroups in uv__process_child_init above
+     * for why this is not a fatal error */
+    SAVE_ERRNO(posix_spawn_fncs->spawnattr.set_groups_np(attrs, ngroups, &group_array, KAUTH_UID_NONE));
+  }
+
+  /* Set flags for spawn behavior 
+    * 1) POSIX_SPAWN_CLOEXEC_DEFAULT: (Apple Extension) All descriptors in
+    * the parent will be treated as if they had been created with O_CLOEXEC.
+    * The only fds that will be passed on to the child are those manipulated
+    * by the file actions
+    * 2) POSIX_SPAWN_SETSIGDEF: Signals mentioned in spawn-sigdefault in
+    * the spawn attributes will be reset to behave as their default
+    * 3) POSIX_SPAWN_SETSIGMASK: Signal mask will be set to the value of
+    * spawn-sigmask in attributes
+    * 4) POSIX_SPAWN_SETSID: Make the process a new session leader if a
+    * detached session was requested. */
+  flags = POSIX_SPAWN_CLOEXEC_DEFAULT |
+    POSIX_SPAWN_SETSIGDEF |
+    POSIX_SPAWN_SETSIGMASK;
+  if (options->flags & UV_PROCESS_DETACHED) 
+    flags |= POSIX_SPAWN_SETSID;
+  err = posix_spawnattr_setflags(attrs, flags);
+  if (err != 0)
+    goto error;
+
+  /*  Reset all signal the child to their default behavior */
+  sigfillset(&signal_set);
+  err = posix_spawnattr_setsigdefault(attrs, &signal_set);
+  if (err != 0) 
+    goto error;
+
+  /*  Reset the signal mask for all signals */
+  sigemptyset(&signal_set);
+  err = posix_spawnattr_setsigmask(attrs, &signal_set);
+  if (err != 0)
+    goto error;
+
+  return err;
+
+error:
+  (void) posix_spawnattr_destroy(attrs);
+  return err;
+}
+
+int uv__spawn_set_posix_spawn_file_actions(posix_spawn_file_actions_t* actions,
+                                           const uv__posix_spawn_fncs_t* posix_spawn_fncs,
+                                           const uv_process_options_t* options,
+                                           int stdio_count,
+                                           int (*pipes)[2])
+{
+  int fd;
+  int err;
+
+  err = posix_spawn_file_actions_init(actions);
+  if (err != 0) {
+    /* If initialization fails, no need to de-init, just return */
+    return err;
+  }
+
+  /* Set the current working directory if requested */
+  if (options->cwd != NULL) {
+    if (posix_spawn_fncs->file_actions.addchdir_np == NULL) {
+      err = UV_ENOSYS;
+      goto error;
+    }
+
+    err = posix_spawn_fncs->file_actions.addchdir_np(actions, options->cwd);
+    if (err != 0)
+      goto error;
+  }
+
+  /* First, duplicate any required fd into orbit, out of the range of 
+   * the descriptors that should be mapped in. */
+  for (fd = 0; fd < stdio_count; fd++) {
+    if (pipes[fd][1] < 0)
+      continue;
+    
+    err = posix_spawn_file_actions_adddup2(actions, pipes[fd][1], stdio_count + fd);
+    if (err != 0)
+      goto error;
+  }
+
+  /*  Second, move the descriptors into their respective places */
+  for (fd = 0; fd < stdio_count; fd++) {
+    if (pipes[fd][1] < 0)
+      continue;
+
+    err = posix_spawn_file_actions_adddup2(actions, stdio_count + fd, fd);
+    if (err != 0)
+      goto error;
+  }
+
+  /*  Finally, close all the superfluous descriptors */
+  for (fd = 0; fd < stdio_count; fd++) {
+    if (pipes[fd][1] < 0)
+      continue;
+    
+    err = posix_spawn_file_actions_addclose(actions, stdio_count + fd);
+    if (err != 0)
+      goto error;
+  }
+
+  /*  Finally process the standard streams as per documentation */
+  for (fd = 0 ; fd < 3 ; fd++) {
+    /*  If ignored, open as /dev/null */
+    int oflags;
+    const int mode = 0;
+
+    oflags = fd == 0 ? O_RDONLY : O_RDWR;
+
+    if (pipes[fd][1] != -1) 
+      continue;
+    
+    err = posix_spawn_file_actions_addopen(actions, fd, "/dev/null", oflags, mode);
+    if (err != 0)
+      goto error;
+  }  
+
+  return 0;
+
+error:
+  (void) posix_spawn_file_actions_destroy(actions);
+  return err;
+}
+
+int uv__spawn_and_init_child_posix_spawn(const uv_process_options_t* options,
+                                         int stdio_count,
+                                         int (*pipes)[2], 
+                                         pid_t* pid,
+                                         const uv__posix_spawn_fncs_t* posix_spawn_fncs) {
+  int err;
+  posix_spawnattr_t attrs;
+  posix_spawn_file_actions_t actions;
+
+  err = uv__spawn_set_posix_spawn_attrs(&attrs, posix_spawn_fncs, options);
+  if (err != 0) 
+    goto error;
+
+  err = uv__spawn_set_posix_spawn_file_actions(&actions, posix_spawn_fncs, options, stdio_count, pipes);
+  if (err != 0) {
+    (void) posix_spawnattr_destroy(&attrs);
+    goto error;
+  }
+
+  /*  Preserve parent environment if not explicitly set */
+  char** env = options->env ? options->env : environ;
+
+  /*  Spawn the child */
+  err = posix_spawnp(pid, options->file, &actions, &attrs, options->args, env);
+
+  /* Destroy the actions/attributes */
+  (void) posix_spawn_file_actions_destroy(&actions);
+  (void) posix_spawnattr_destroy(&attrs);
+
+error:
+  /* In an error situation, the attributes and file actions are 
+   * already destroyed, only the happy path requires cleanup */
+  return UV__ERR(err);
+}
+#endif
+
+int uv__spawn_and_init_child_fork(const uv_process_options_t* options,
+                                  int stdio_count,
+                                  int (*pipes)[2],
+                                  int error_fd,
+                                  pid_t* pid) {
+  *pid = fork();
+
+  if (*pid == -1) {
+    /* Failed to fork */
+    return UV__ERR(errno);
+  }
+
+  if (*pid == 0) {
+    /* Fork succeeded, in the child process */
+    uv__process_child_init(options, stdio_count, pipes, error_fd);
+    abort();
+  }
+
+  /* Fork succeeded, in the parent process */
+  return 0;
+}
+
+int uv__spawn_and_init_child(const uv_process_options_t* options,
+                             int stdio_count,
+                             int (*pipes)[2],
+                             int error_fd,
+                             pid_t* pid) {
+  int err = 0;
+
+#if defined(__APPLE__) 
+  uv_once(&posix_spawn_init_fncs_once, uv__spawn_init_posix_spawn_fncs);
+
+  /* Especial child process spawn case for macOS Big Sur (11.0) onwards 
+   *
+   * Big Sur introduced a significant performance degradation on a call to
+   * fork/exec when the process has many pages mmaped in with MAP_JIT, like, say
+   * a javascript interpreter. Electron-based applications, for example,
+   * are impacted; though the magnitude of the impact depends on how much the
+   * app relies on subprocesses. 
+   * 
+   * On macOS, though, posix_spawn is implemented in a way that does not 
+   * exhibit the problem. This block implements the forking and preparation
+   * logic with poxis_spawn and its related primitves. It also takes advantage of 
+   * the macOS extension POSIX_SPAWN_CLOEXEC_DEFAULT that makes impossible to
+   * leak descriptors to the child process.
+   */
+  err = uv__spawn_and_init_child_posix_spawn(options,
+                                              stdio_count,
+                                              pipes,
+                                              pid,
+                                              &posix_spawn_fncs);
+
+  /* The posix_spawn flow will return UV_ENOSYS if any of the posix_spawn_x_np
+   * non-standard functions is both _needed_ and _undefined_. In those cases, 
+   * default back to the fork/execve strategy. For all other errors, just fail. */
+  if(err != UV_ENOSYS) {
+    return err;
+  } 
+#endif  
+  err = uv__spawn_and_init_child_fork(options, stdio_count, pipes, error_fd, pid);
+
+  return err;
+}
 
 int uv_spawn(uv_loop_t* loop,
              uv_process_t* process,
@@ -486,21 +787,16 @@ int uv_spawn(uv_loop_t* loop,
 
   /* Acquire write lock to prevent opening new fds in worker threads */
   uv_rwlock_wrlock(&loop->cloexec_lock);
-  pid = fork();
 
-  if (pid == -1) {
-    err = UV__ERR(errno);
+  /* Spawn the child */
+  err = uv__spawn_and_init_child(options, stdio_count, pipes, signal_pipe[1], &pid);
+  if (err != 0) {
     uv_rwlock_wrunlock(&loop->cloexec_lock);
     uv__close(signal_pipe[0]);
     uv__close(signal_pipe[1]);
     goto error;
   }
 
-  if (pid == 0) {
-    uv__process_child_init(options, stdio_count, pipes, signal_pipe[1]);
-    abort();
-  }
-
   /* Release lock in parent process */
   uv_rwlock_wrunlock(&loop->cloexec_lock);
   uv__close(signal_pipe[1]);
